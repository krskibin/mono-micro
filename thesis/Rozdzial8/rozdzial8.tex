\chapter{Dyskusja rezultatów~i wnioski końcowe}
\label{roz8}
W ramach pracy udało się przygotować architekturę dla dwóch aplikacji, jednej opartej~o podejście monolityczne, drugiej~o mikrousługi, a następnie je zaimplementować. Szczegółowo przedstawiono wszystkie założenia~i problemy, które mogą się pojawić podczas tworzenia aplikacji, a także środowisko programistyczne potrzebne do ich uruchomienia. Opisano strukturę bazy danych, wykorzystane biblioteki, wymagania funkcyjne~i niefunkcyjne aplikacji. Następnie omówiono proces tworzenia serwisów, zaprezentowano przykłady wykorzystanego kodu, tłumacząc jego działanie~i zwracając uwagę na jego istotne kwestię. Przeprowadzono proces konteneryzacji projektu, tak aby można było go zintegrować~z dowolną platformą oferującą hosting serwisów internetowych. Przygotowano~i przeprowadzono badania mające sprawdzić różnicę pomiędzy wydajnością aplikacji, ich skalowalnością~i to jak te czynniki wypływają na czasy odpowiedzi żądań. Platformy przeanalizowano pod kątem ich implementacji, tego jak trudne były do osiągnięcia zakładane architektury, jakie technologie były wykorzystane. Uzyskane rezultaty pozwalają na ocenę obu podejść. 
\textit{Richard Rodger} w książce \textit{Tao mikrousług. Projektowanie~i wdrażanie}, napisał, że: \begin{quotation}
  Mikrousługi nie są cudownym panaceum, dzięki któremu możesz~z dnia na dzień rozwiązać wszystkie swoje problemy związane~z rozwojem oprogramowania\cite{Rodger:2019}.
\end{quotation}
Wyniki badań jasno przedstawiły, że powyższe stwierdzenie jest prawdą. Mikrousługi posiadają szereg atutów, takich jak to, że ich implementacja nie musi sprowadzać się do jednego projektu, w danym języku, a dzięki uniwersalnemu sposobowi komunikacji pomiędzy komponentami możliwości ich rozwoju jest wiele. Każda~z poszczególnych usług ma swój zakres odpowiedzialności, który jest łatwy do przestrzegania, natomiast trudniejsze do osiągnięcia jest to, aby dane dwie mikrousługi powielały go. Istotne jest to, że każda~z usług to osobny projekt, który nie musi być tworzony przez jeden zespół, tylko kilka równolegle. Co~w zasadzie sprawia, że sama aplikacja posiada więcej możliwości, jeżeli chodzi~o jej skalowanie, można tworzyć instancję dla poszczególnych usług, które są najbardziej obciążone~i im przekazywać najwięcej zasobów, aby działały wydajniej. Niestety przy tak niewielkich aplikacjach jak te stworzone~w ramach niniejszej pracy, rozwiazanie oparte~o mikrousługi okazało się powodować, że podział architektury był zbyt skomplikowany. Stworzenie osobnych serwisów, które musiały się~z sobą porozumiewać~w celu uwierzytelniania tokenów, a także~w warstwie interfejsu użytkownika sprawiło, że liczba interakcji wewnątrz sieci niepotrzebnie wzrosła, dodatkowo ją obciążając. Innym niekorzystnym zjawiskiem było powielanie kodu~i danych, implementowanie tych samych mechanizmów do obsługi bazy danych dla trzech aplikacji, wykorzystywanie identycznych plików konfiguracyjnych. Wnioski~z tych obserwacji potwierdzają przeprowadzone badania, gdzie aplikacja monolityczna~o wiele lepiej radzi sobie~z wydajnością, a nawet skalowalnością. Mimo, że to jedna centralna aplikacja to~i tako możliwe było stworzenie jej kilku instancji, których ruch był obsługiwany przez \textit{load balancer}, dzięki czemu~w tych testach wypadła lepiej od serwisu opartego~o mikrousługi. Nie mniej jednak także ta architektura posiada wady, takie jak potrzeba utrzymywania jednego projektu, opartego~o hierarchię klas, gdzie obsługa ich zakresów~i uprawień spoczywa na programiście. Poszczególne komponenty nie są już tak odizolowane jak~w aplikacji mikrousługowej, co może doprowadzić do zawiłości~i mieszania się odpowiedzialności. To~w rezultacie sprawia, że trudniej jest utrzymać porządek~w kodzie. Gdy jedna mikrousługa będzie wymagała usprawnienia, to wystarczą zmiany wyłącznie~w jej ramach, bez zmian~w całym systemie, co jest niemożliwe~w aplikacji monolitycznej. Także możliwości skalowania serwisu są ograniczone, można uruchomić kilka instancji, ale nie jest to tak elastyczne rozwiazanie jak~w przypadku mikrousług. Analiza wykazała, że wady te nie są istotne przy niewielkich projektach, w przypadku aplikacji monolitycznych~o wiele łatwiej jest rozpocząć projekt, wymaga on mniej konfiguracji. Centralna baza danych jest~o wiele prostsza~w utrzymaniu~i porządkowaniu danych. Architektura centralna jest także, tą przedstawianą~w dokumentacjach projektów\cite{flask} i jej odwzorowanie, a także zaprojektowanie jest~o wiele prostsze. Dodatkowo istniej wiele zewnętrznych modułów pozwalających na znaczne uproszczenie poszczególnych mechanizmów, takich jak uwierzytelnianie, przesyłanie formularzy, czy obsługa danych. 

Przeprowadzone badania wskazują na lepszą wydajność serwisu monolitycznego, ale należy zwrócić uwagę, że stworzona aplikacja jest niewielka, generowane przez nią szablony \textit{HTML} były małej wielkości. Mikrousługi pomimo, że przesyłają jedynie obiekty \textit{JSON}, to muszą je jeszcze serializować, co mogło obciążyć aplikację bez uwidaczniania zalety tego rozwiązania. Dodatkowo usługi uruchomione byłby wewnątrz kontenerów, które mimo tego, że mogą być stosowane~w rozwiązaniach produkcyjnych, to wymagają więcej zasobów. Uruchamianie większej ilości kontenerów~w przypadku aplikacji zdecentralizowanej również mogło wpłynąć na czasy ich odpowiedzi. Innym czynnikiem, który mógł wpłynąć na badania były ograniczenia sprzętowe fizycznej maszyny. Nie była to jednostka przygotowana~z myślą wyłącznie~o rozwiązaniach serwerowych~i posiadła ona ograniczoną liczbę pamięci \textit{RAM}, procesor starszej generacji~i niewielką przestrzeń dyskową. Niemniej jednak przeprowadzone badania miały wyłącznie cel porównawczy, a ich wyniki świadczyć mogą, że zgodnie~z tezą \textit{Richarda Rodgera}, mikrousługi nie wszędzie sprawdzą się jako rozwiazanie najbardziej optymalne\cite{Rodger:2019}.

Ostatecznie można przejść do wniosku, że wybór pomiędzy architekturą monolityczną, a mikrousługami powinien być kierowany głównie ze względu na charakter projektu. Jeżeli ma on być tworzony~w ramach większego zespołu znającego kilka technologii, rozsądne byłoby podzielenie go, tak aby każdy~z nich pracował nad osobną usługą, wówczas przy większych serwisach, możliwe będzie, że wady rozwiązania opartego~o mikrousługi będą mniej istotne. Większa organizacja będzie mogła zainwestować pieniądze~w infrastrukturę sieciową, tak aby odpowiednio przystosować ją do rozwiązań zdecentralizowanych. 

Architektura monolityczna to nadal dobry pomysł na mniejsze aplikacje, gdzie zespół nie składa się~z dużej liczy osób znających kilka technologii. Rozpoczęcie projektu jest wówczas~o wiele prostsze, a wdrożenie takiej aplikacji szybsze. W razie, gdyby urósł on do większych rozmiarów istnieje opcja przepisania go na mniejsze aplikacje~i zmiana architektury na tą opartą~o mikrousługi.

Każdy przypadek aplikacji powinien być indywidualnie przemyślany. Zespół musi być świadomy wszystkich wad~i zalet danych architektur, przewidzieć przyszłe koszty infrastruktury, a także zaplanować czas na niezbędne konfigurację wybranych rozwiązań. Realizacja projektu~w ramach niniejszej pracy pokazała jak istotnym elementem aplikacji internetowych jest ich konfiguracja, odpowiednie zaplanowanie systemu komunikacji między danymi komponentami~i opracowanie architektury tak, aby nie powielała ona niepotrzebnie poszczególnych modułów. W ramach usprawnienia obecnej implementacji projektu mikrousługowego można byłoby inaczej zaplanować odpowiedzialność poszczególnych serwisów, zrezygnować~z osobnego modułu uwierzytelniania~i wielu baz danych. Podzielić cały system jedynie na dwie usługi, jedną odpowiedzialną za przetwarzanie~i przechowywanie wszystkich informacji, drugą za interfejs użytkownika. Byłby to idealny kompromis między architekturą monolityczną~i mikrousługami.